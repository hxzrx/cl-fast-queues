(ql:quickload :cl-fast-queues)
(ql:quickload :local-time)
(ql:quickload :queues)
(ql:quickload :queues.simple-cqueue)
(ql:quickload :queues.simple-queue)
(in-package :cl-fast-queues)


(defparameter *times* (loop for i from 3 to 8
                            collect (expt 10 i)))
(defparameter *lengths* (loop for i from 3 to 8
                              collect (expt 10 i)))
(defparameter *max-times* (expt 10 8))
(defparameter *threads-num* '(1 2 3 4 5 6 7 8))


;;; ------- FIFO, Single thread, init-length 1000 -------

(dolist (num *times*)
  (format t "~&unsafe fifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-fifo :init-length 1000)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "~&safe fifo, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-fifo :init-length 1000)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*) ; queues.simple-queue
  (format t "~&queues.simple-queue, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (sb-ext:gc :full t)
  (time (let ((queue (queues:make-queue :simple-queue)))
          (dotimes (i num)
            (queues:qpush queue i))
          (dotimes (i num)
            (queues:qpop queue)))))

(dolist (num *times*) ; queues.simple-cqueue
  (format t "~&queues.simple-cqueue, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (sb-ext:gc :full t)
  (time (let ((queue (queues:make-queue :simple-cqueue)))
          (dotimes (i num)
            (queues:qpush queue i))
          (dotimes (i num)
            (queues:qpop queue)))))

(dolist (num *times*)
  (format t "~&cl-speedy-queue: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-speedy-queue:make-queue num)))
          (dotimes (i num)
            (cl-speedy-queue:enqueue i queue))
          (dotimes (i num)
            (cl-speedy-queue:dequeue queue)))))

(dolist (num *times*)
  (format t "~&list queue: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues::%make-list-queue num)))
          (dotimes (i num)
            (cl-fast-queues::%list-queue-enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues::%list-queue-dequeue queue)))))


;;; ------- LIFO, Single thread, init-length 1000 -------

(dolist (num *times*)
  (format t "~&unsafe lifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-lifo :init-length 1000)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "~&safe lifo, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-lifo)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "~&cl-speedy-lifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-speedy-lifo:make-queue num)))
          (dotimes (i num)
            (cl-speedy-lifo:enqueue i queue))
          (dotimes (i num)
            (cl-speedy-lifo:dequeue queue)))))

(dolist (num *times*)
  (format t "~&list lifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue nil))
          (dotimes (i num)
            (push i queue))
          (dotimes (i num)
            (pop queue)))))


;;; ------- Single thread, init-length from 10^3 to 10^8 -------

;; unsafe fifo
(dolist (len *lengths*)
  (format t "~&unsafe fifo, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-fifo :init-length len)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))

;; safe fifo
(dolist (len *lengths*)
  (format t "~&safe fifo, single thread, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-fifo)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))


;; lifo
(dolist (len *lengths*)
  (format t "~&unsafe lifo, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-lifo :init-length len)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))

(dolist (len *lengths*)
  (format t "~&safe lifo, single thread, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-lifo :init-length len)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))


;;; ------- Multi-threads -------

;; safe fifo

(dolist (t-num *threads-num*)
  (format t "~&safe fifo, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 8))
         (queue (make-safe-fifo :init-length 1000))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))


;; safe lifo

(dolist (t-num *threads-num*)
  (format t "~&safe fifo, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 8))
         (queue (make-safe-lifo))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))

(dolist (t-num *threads-num*)
  (format t "~&speedy-fifo-safe, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 8))
         (queue (cl-speedy-queue-safe:make-queue *max-times*))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (cl-speedy-queue-safe:enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (cl-speedy-queue-safe:dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))


;; simple-cqueue

(dolist (t-num *threads-num*)
  (format t "~&simple cqueue, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 8))
         (queue (queues:make-queue :simple-cqueue))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (queues:qpush queue item))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (queues:qpop queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))

#+sbcl
(dolist (t-num *threads-num*) ; 10s
  (format t "~&common lisp vanilla list, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 8))
         (queue (list nil))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (sb-ext:atomic-push item (car queue)))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (sb-ext:atomic-pop (car queue)))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))

#+sbcl
(dolist (t-num *threads-num*)  ; 10s
  (format t "~&common lisp list, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 8))
         (queue (sb-concurrency:make-queue))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (sb-concurrency:enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (sb-concurrency:dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))
