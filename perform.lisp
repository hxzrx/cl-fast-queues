(ql:quickload :local-time)

(in-package :cl-fast-queues)


(defparameter *times* (loop for i from 3 to 8
                            collect (expt 10 i)))
(defparameter *lengths* (loop for i from 3 to 8
                              collect (expt 10 i)))
(defparameter *max-times* (expt 10 8))


;;; ------- FIFO, Single thread, init-length 1000 -------

(dolist (num *times*)
  (format t "unsafe fifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-fifo)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "safe fifo, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-fifo :waitp nil)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "safe fifo, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-fifo :waitp t)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "cl-speedy-queue: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-speedy-queue:make-queue num)))
          (dotimes (i num)
            (cl-speedy-queue:enqueue i queue))
          (dotimes (i num)
            (cl-speedy-queue:dequeue queue)))))

(dolist (num *times*)
  (format t "list queue: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues::%make-list-queue num)))
          (dotimes (i num)
            (cl-fast-queues::%list-queue-enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues::%list-queue-dequeue queue)))))


;;; ------- LIFO, Single thread, init-length 1000 -------

(dolist (num *times*)
  (format t "unsafe lifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-lifo)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "safe lifo, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-lifo :waitp nil)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "safe lifo, single thread: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-lifo :waitp t)))
          (dotimes (i num)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i num)
            (cl-fast-queues:dequeue queue)))))

(dolist (num *times*)
  (format t "cl-speedy-lifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-speedy-lifo:make-queue num)))
          (dotimes (i num)
            (cl-speedy-lifo:enqueue i queue))
          (dotimes (i num)
            (cl-speedy-lifo:dequeue queue)))))

(dolist (num *times*)
  (format t "list lifo: 10^~d times.~%" (log num 10))
  (sb-ext:gc :full t)
  (time (let ((queue nil))
          (dotimes (i num)
            (push i queue))
          (dotimes (i num)
            (pop queue)))))


;;; ------- Single thread, init-length from 10^3 to 10^8 -------

;; unsafe fifo
(dolist (len *lengths*)
  (format t "unsafe fifo, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-fifo len)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))

;; safe fifo, waitp nil
(dolist (len *lengths*)
  (format t "safe fifo, single thread, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-fifo :init-length len :waitp nil)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))

;; safe fifo, waitp t
(dolist (len *lengths*)
  (format t "safe fifo, single thread, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-fifo :init-length len :waitp t)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))


;; lifo
(dolist (len *lengths*)
  (format t "unsafe lifo, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-unsafe-lifo :init-length len)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))

(dolist (len *lengths*)
  (format t "safe lifo, single thread, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-lifo :init-length len :waitp nil)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))

(dolist (len *lengths*)
  (format t "safe lifo, single thread, init-length: 10^~d.~%" (log len 10))
  (sb-ext:gc :full t)
  (time (let ((queue (cl-fast-queues:make-safe-lifo :init-length len :waitp t)))
          (dotimes (i *max-times*)
            (cl-fast-queues:enqueue i queue))
          (dotimes (i *max-times*)
            (cl-fast-queues:dequeue queue)))))

;;; ------- Multi-threads -------

(defparameter *threads-num* '(1 2 3 4))

;; safe fifo, waitp nil
(dolist (t-num *threads-num*)
  (format t "~&safe fifo, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 888))
         (queue (make-safe-fifo :waitp nil))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))

;; safe fifo, waitp t
(dolist (t-num *threads-num*)
  (format t "~&safe fifo, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 888))
         (queue (make-safe-fifo :waitp t))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))


;; safe lifo, waitp nil
(dolist (t-num *threads-num*)
  (format t "~&safe lifo, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 888))
         (queue (make-safe-lifo :waitp nil))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))

;; safe lifo, waitp t
(dolist (t-num *threads-num*)
  (format t "~&safe lifo, threads: ~d, ~d times.~%" t-num *max-times*)
  (sb-ext:gc :full t)
  (let* ((num-each-thread (truncate (/ *max-times* t-num)))
         (lst (make-list num-each-thread :initial-element 888))
         (queue (make-safe-lifo :waitp t))
         (counter (list 0))
         (ts1 (local-time:now))
         (ts2 nil))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (enqueue item queue))
                          (sb-ext:atomic-incf (car counter)))))
    (dotimes (th t-num)
      (bt:make-thread #'(lambda ()
                          (dolist (item lst)
                            (dequeue queue))
                          (sb-ext:atomic-incf (car counter)))))
    (loop while (/= (car counter) (* 2 t-num))
          do (bt:thread-yield))
    (setf ts2 (local-time:now))
    (format t "~&Time cost: ~d.~%" (local-time:timestamp-difference ts2 ts1))))
